<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
  <title>gesture2sound</title>
  <style>
    html, body {
      height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: white;
    }
    #pad {
      height: 100%;
      touch-action: none;           /* ← 重要: ブラウザのスクロール/ズーム抑止 */
      user-select: none;
      -webkit-user-select: none;
      background: radial-gradient(1200px 800px at 50% 20%, #1a2330 0%, #0b0f14 55%, #070a0d 100%);
      color: #e7eef7;
      position: relative;
      overflow: hidden;
    }
    .hud {
      position: fixed; left: 12px; top: 12px;
      padding: 10px 12px; border-radius: 14px;
      background: rgba(10,16,22,0.72);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
      min-width: 280px;
      font-variant-numeric: tabular-nums;
    }
    .row { display: flex; gap: 10px; align-items: center; margin: 6px 0; }
    .row b { width: 90px; font-size: 12px; opacity: .85; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    button {
      padding: 10px 12px; border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #e7eef7; font-weight: 700;
    }
    .note {
      position: absolute;
      width: 14px; height: 14px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      box-shadow: 0 0 0 2px rgba(255,255,255,0.10), 0 8px 26px rgba(0,0,0,0.35);
    }
    .anchor {
      width: 10px; height: 10px;
      box-shadow: 0 0 0 2px rgba(140,200,255,0.25);
      opacity: .9;
    }
    .hint {
      position: fixed; right: 12px; bottom: 12px;
      padding: 10px 12px; border-radius: 14px;
      background: rgba(10,16,22,0.72);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(10px);
      max-width: 360px;
      font-size: 12px; line-height: 1.4;
      opacity: .9;
    }
    .hint a {
      color: gray !important;
    }
  </style>
</head>
<body>
  <div id="pad"></div>

  <div class="hud">
    <h1>gesture2sound</h1>
    <div class="row">
      <button id="start">Audio ON</button>
      <span class="mono" id="state">stopped</span>
    </div>
    <!--
    <div class="row"><b>pointers</b><span class="mono" id="count">0</span></div>
    <div class="row"><b>last</b><span class="mono" id="last">-</span></div>
    <div class="row"><b>mapping</b><span class="mono">dx→freq(log), dy→gain(dB), pressure→timbre(step)</span></div>
    -->
  </div>

  <div class="hint">
    <b>操作</b><br>
    ・押した点がアンカー。そこからの相対移動で鳴ります（マルチポインタ / 和音OK）。<br>
    ・左右(dx): 周波数（対数 / オクターブ）<br>
    ・上下(dy): 音量（対数 / dB）<br>
    <!--※ iOSは最初に Audio O N を押してください。<br>-->
    <a href=https://github.com/code4fukui/gesture2sound/>src on GitHub</a>
  </div>

<script>
(() => {
  const pad = document.getElementById("pad");
  const btnStart = document.getElementById("start");
  const elState = document.getElementById("state");
  const elCount = document.getElementById("count");
  const elLast  = document.getElementById("last");

  // ===== Audio Graph =====
  /** @type {AudioContext|null} */
  let ac = null;
  let master = null;

  function ensureAudio() {
    if (ac) return;
    ac = new (window.AudioContext || window.webkitAudioContext)();

    master = ac.createGain();
    master.gain.value = 0.9;
    master.connect(ac.destination);

    elState.textContent = "ready";
  }

  btnStart.addEventListener("click", async () => {
    ensureAudio();
    if (ac && ac.state !== "running") await ac.resume();
    elState.textContent = "running";
  });

  // ===== Synthesis mapping =====
  const BASE_FREQ = 220;     // anchor 기준
  const OCT_RANGE = 5;       // full-range move -> ±OCT_RANGE
  const MAX_DX = 260;        // px clamp for dx mapping
  const MAX_DY = 260;        // px clamp for dy mapping
  const DB_MIN = -24;        // dy down -> quieter
  const DB_MAX = 0;

  const TIMBRE_STEPS = 8;    // 0..8 (9段階)
  const HARMONICS = 64;      // square-ish richness
  const VOICE_RELEASE = 0.03;

  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function dbToGain(db) { return Math.pow(10, db / 20); }

  function dxToFreq(dx) {
    const x = clamp(dx / MAX_DX, -1, 1);
    const oct = x * OCT_RANGE;
    return BASE_FREQ * Math.pow(2, oct);
  }

  function dyToGain(dy) {
    // up is louder: dy negative => increase
    const y = clamp((-dy) / MAX_DY, -1, 1);
    const db = DB_MIN + (y + 1) * 0.5 * (DB_MAX - DB_MIN);
    return dbToGain(db);
  }

  function pressureToStep(p) {
    const q = clamp(p, 0, 1);
    return Math.round(q * TIMBRE_STEPS);
  }

  // PeriodicWave cache (step -> wave)
  const waveCache = new Map();
  function getMorphWave(step) {
    const key = step|0;
    if (waveCache.has(key)) return waveCache.get(key);
    const m = key / TIMBRE_STEPS; // 0..1

    const real = new Float32Array(HARMONICS + 1);
    const imag = new Float32Array(HARMONICS + 1);

    // sine: only fundamental
    imag[1] = 1.0;

    // add odd harmonics gradually toward square
    for (let n = 3; n <= HARMONICS; n += 2) {
      imag[n] = m * (1 / n);
    }

    // mild normalization so loudness doesn't jump too much
    let s = 0;
    for (let i = 1; i <= HARMONICS; i++) s += Math.abs(imag[i]);
    const scale = s > 0 ? (1 / s) : 1;
    for (let n = 3; n <= HARMONICS; n += 2) imag[n] *= 2.4 * scale;

    const w = ac.createPeriodicWave(real, imag, { disableNormalization: false });
    waveCache.set(key, w);
    return w;
  }

  function getPressureFromEvent(e) {
    // PointerEvent.pressure: pen works best. touch often constant (0 or 0.5) depending on platform.
    let p = typeof e.pressure === "number" ? e.pressure : 0;

    // Some browsers give 0 for mouse; make it usable
    if (e.pointerType === "mouse") p = 0.2;

    // If touch pressure is useless, you can try width/height as a weak proxy (often constant too).
    if (e.pointerType === "touch" && (!p || p === 0)) {
      const w = (typeof e.width === "number") ? e.width : 0;
      const h = (typeof e.height === "number") ? e.height : 0;
      const area = w * h; // arbitrary
      // Map area to 0..1 gently (tuned to be non-explosive)
      p = clamp(area / 900, 0, 1);
    }

    return clamp(p, 0, 1);
  }

  // ===== Voices (multi pointer) =====
  /**
   * voices: pointerId -> {
   *   id, type, anchorX, anchorY, x, y,
   *   osc, gain, anchorEl, headEl
   * }
   */
  const voices = new Map();

  function makeDot(className, color) {
    const el = document.createElement("div");
    el.className = "note " + (className || "");
    el.style.background = color;
    pad.appendChild(el);
    return el;
  }

  function setDotPos(el, x, y) {
    el.style.left = x + "px";
    el.style.top  = y + "px";
  }

  function colorForType(t) {
    if (t === "pen") return "rgba(255,180,120,0.95)";
    if (t === "touch") return "rgba(140,200,255,0.95)";
    return "rgba(220,220,220,0.9)";
  }

  function startVoice(e) {
    ensureAudio();
    if (!ac) return;

    // iOS gesture resume
    if (ac.state !== "running") ac.resume();

    const rect = pad.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const id = e.pointerId;
    const type = e.pointerType || "unknown";

    // Create voice nodes
    const osc = ac.createOscillator();
    const g = ac.createGain();

    g.gain.value = 0.0001; // start silent; will set quickly
    osc.setPeriodicWave(getMorphWave(0));
    osc.frequency.value = BASE_FREQ;

    osc.connect(g).connect(master);
    osc.start();

    // Visuals
    const col = colorForType(type);
    const anchorEl = makeDot("anchor", col);
    const headEl   = makeDot("", col);

    setDotPos(anchorEl, x, y);
    setDotPos(headEl, x, y);

    voices.set(id, { id, type, anchorX: x, anchorY: y, x, y, osc, gain: g, anchorEl, headEl: [headEl] });

    pad.setPointerCapture?.(id);

    updateVoice(e);
    updateHud(e);
  }

  function updateVoice(e) {
    const v = voices.get(e.pointerId);
    if (!v || !ac) return;

    const rect = pad.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    v.x = x;
    v.y = y;
    //setDotPos(v.headEl, x, y);
    const type = e.pointerType || "unknown";
    const col = colorForType(type);
    const headEl   = makeDot("", col);
    setDotPos(headEl, x, y);
    v.headEl.push(headEl);

    const dx = x - v.anchorX;
    const dy = y - v.anchorY;

    const freq = dxToFreq(dx);
    const gain = dyToGain(dy);

    const p = getPressureFromEvent(e);
    const step = pressureToStep(p);

    const now = ac.currentTime;
    v.osc.frequency.setTargetAtTime(freq, now, 0.01);
    v.gain.gain.setTargetAtTime(clamp(gain, 0.0001, 1.0), now, 0.015);
    v.osc.setPeriodicWave(getMorphWave(step));

    // HUD last
    if (elLast) elLast.textContent =
      `id=${v.id} type=${v.type} dx=${dx.toFixed(0)} dy=${dy.toFixed(0)} ` +
      `freq=${freq.toFixed(1)}Hz gain=${gain.toFixed(4)} p=${p.toFixed(2)} step=${step}/${TIMBRE_STEPS}`;
  }

  function endVoice(e) {
    const v = voices.get(e.pointerId);
    if (!v || !ac) return;

    const now = ac.currentTime;
    v.gain.gain.setTargetAtTime(0.0001, now, VOICE_RELEASE);

    // stop oscillator shortly after release
    v.osc.stop(now + 0.08);

    // cleanup DOM a bit later
    setTimeout(() => {
      v.anchorEl.remove();
      v.headEl.forEach(i => i.remove());
    }, 120);

    voices.delete(e.pointerId);
    updateHud(e);
  }

  function updateHud(e) {
    if (elCount) elCount.textContent = String(voices.size);
    if (ac) elState.textContent = ac.state;
  }

  // ===== Pointer Events (pen + touch unified) =====
  pad.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    startVoice(e);
  }, { passive: false });

  pad.addEventListener("pointermove", (e) => {
    if (!voices.has(e.pointerId)) return;
    e.preventDefault();
    updateVoice(e);
  }, { passive: false });

  pad.addEventListener("pointerup", (e) => {
    e.preventDefault();
    endVoice(e);
  }, { passive: false });

  pad.addEventListener("pointercancel", (e) => {
    e.preventDefault();
    endVoice(e);
  }, { passive: false });

  // If the browser fires lostpointercapture, ensure cleanup
  pad.addEventListener("lostpointercapture", (e) => {
    if (voices.has(e.pointerId)) endVoice(e);
  });

})();
</script>
</body>
</html>
