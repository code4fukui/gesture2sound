<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Log XY Synth (Pressure: Sine→Square)</title>
  <style>
    :root { color-scheme: light dark; }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #pad {
      height: 100%;
      touch-action: none; /* important for pointer events */
      display: grid;
      place-items: center;
      user-select: none;
      -webkit-user-select: none;
    }
    .hud {
      position: fixed; left: 12px; top: 12px;
      padding: 10px 12px; border-radius: 12px;
      background: color-mix(in srgb, canvas 80%, transparent);
      border: 1px solid color-mix(in srgb, canvastext 15%, transparent);
      backdrop-filter: blur(8px);
      min-width: 240px;
    }
    .row { display: flex; gap: 10px; align-items: center; margin: 6px 0; }
    .row label { width: 88px; opacity: 0.85; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    input[type="range"] { width: 140px; }
    .hint {
      position: fixed; right: 12px; bottom: 12px;
      padding: 10px 12px; border-radius: 12px;
      background: color-mix(in srgb, canvas 80%, transparent);
      border: 1px solid color-mix(in srgb, canvastext 15%, transparent);
      backdrop-filter: blur(8px);
      max-width: 320px;
      font-size: 12px;
      line-height: 1.35;
      opacity: .9;
    }
    .center {
      text-align: center;
      padding: 18px 22px;
      border-radius: 16px;
      border: 1px dashed color-mix(in srgb, canvastext 25%, transparent);
      background: color-mix(in srgb, canvas 85%, transparent);
    }
    button {
      padding: 10px 14px; border-radius: 12px;
      border: 1px solid color-mix(in srgb, canvastext 20%, transparent);
      background: color-mix(in srgb, canvas 92%, transparent);
      font-weight: 600;
    }
  </style>
</head>

<body>
  <div id="pad">
    <div class="center">
      <div style="font-weight:700;margin-bottom:10px;">Tap / Press to Play</div>
      <button id="btnStart">Start Audio</button>
      <div style="opacity:.75;font-size:12px;margin-top:10px;">
        押した地点からの相対移動で「周波数・音量」を対数変化<br/>
        圧力(ペン)で「正弦波→矩形波」を段階的に変化
      </div>
    </div>
  </div>

  <div class="hud">
    <div class="row"><label>state</label><span class="mono" id="state">stopped</span></div>
    <div class="row"><label>pointer</label><span class="mono" id="ptype">-</span></div>
    <div class="row"><label>freq</label><span class="mono" id="freq">-</span></div>
    <div class="row"><label>gain</label><span class="mono" id="gain">-</span></div>
    <div class="row"><label>pressure</label><span class="mono" id="press">-</span></div>
    <div class="row"><label>wave step</label><span class="mono" id="step">-</span></div>

    <div class="row" id="simRow" style="display:none;">
      <label>simulate</label>
      <input id="simPressure" type="range" min="0" max="1" step="0.01" value="0.25" />
      <span class="mono" id="simVal">0.25</span>
    </div>
  </div>

  <div class="hint">
    <b>使い方</b><br/>
    1) Start Audio → 画面を押すと発音。<br/>
    2) 押し始めた点からの相対移動：<br/>
    ・左右：周波数 (対数) / ・上下：音量 (対数dB)<br/>
    3) 圧力：正弦→矩形へ段階変化（ペン入力が理想）。<br/>
    ※ iPhone指は圧力が取れないのでスライダーで代用します。
  </div>

<script>
(() => {
  // ===== UI =====
  const $ = (id) => document.getElementById(id);
  const elState = $("state");
  const elPType = $("ptype");
  const elFreq  = $("freq");
  const elGain  = $("gain");
  const elPress = $("press");
  const elStep  = $("step");
  const simRow  = $("simRow");
  const simPressure = $("simPressure");
  const simVal  = $("simVal");
  const btnStart = $("btnStart");
  const pad = $("pad");

  simPressure.addEventListener("input", () => {
    simVal.textContent = Number(simPressure.value).toFixed(2);
  });

  // ===== Audio =====
  /** @type {AudioContext | null} */
  let ac = null;
  let master = null;
  let osc = null;

  // press start reference
  let isDown = false;
  let startX = 0, startY = 0;
  let pointerType = "unknown";

  // params
  const BASE_FREQ = 220;      // A3
  const FREQ_OCT  = 4.0;      // 左右移動で ±4oct 相当
  const GAIN_DB_RANGE = 48;   // 上下移動で ±48dB 相当
  const MAX_DX_PX = 240;      // これ以上動いても飽和させる
  const MAX_DY_PX = 240;

  const WAVE_STEPS = 8;       // 正弦→矩形へ 0..8段階

  function ensureAudio() {
    if (ac) return;
    ac = new (window.AudioContext || window.webkitAudioContext)();

    master = ac.createGain();
    master.gain.value = 0.0001; // silent until down
    master.connect(ac.destination);

    osc = ac.createOscillator();
    osc.frequency.value = BASE_FREQ;

    // 初期は正弦に近い波形
    osc.setPeriodicWave(makeMorphWave(0));
    osc.connect(master);
    osc.start();

    elState.textContent = "ready";
  }

  // 対数マッピング（周波数）：base * 2^(x * octaves)
  function freqFromDx(dx) {
    const x = clamp(dx / MAX_DX_PX, -1, 1);
    const oct = x * FREQ_OCT;
    return BASE_FREQ * Math.pow(2, oct);
  }

  // 対数マッピング（音量）：dB を線形に動かして gain=10^(dB/20)
  function gainFromDy(dy) {
    // 上へ行くほど大きく：dy(下+)なので符号反転
    const y = clamp((-dy) / MAX_DY_PX, -1, 1);
    const db = y * (GAIN_DB_RANGE / 2);
    return Math.pow(10, db / 20);
  }

  // 0..1 pressure -> step 0..WAVE_STEPS
  function stepFromPressure(p) {
    const cl = clamp(p, 0, 1);
    return Math.round(cl * WAVE_STEPS);
  }

  // 正弦(=基本波だけ) と 矩形(=奇数倍音 1/n) を係数で補間した PeriodicWave
  function makeMorphWave(m) {
    // m: 0..1 (0=sine, 1=square)
    const H = 64; // 倍音数（多いほど矩形っぽい）
    const real = new Float32Array(H + 1);
    const imag = new Float32Array(H + 1);

    // i=1 が基本波。squareは奇数倍音に 1/n。
    for (let n = 1; n <= H; n++) {
      if (n === 1) {
        // sine: 1.0, square: 1.0
        imag[n] = 1.0;
      } else if (n % 2 === 1) {
        // sineは0、squareは 1/n を混ぜる
        imag[n] = m * (1 / n);
      } else {
        imag[n] = 0;
      }
      real[n] = 0;
    }

    // 正弦の純度を保つため、基本波も少し補正（低圧でも少し矩形寄りにしたいなら調整）
    // ここでは基本波は常に1.0、上の奇数倍音が増えていく設計。

    // normalize（大きすぎると音量感が跳ねるので軽く抑える）
    let sum = 0;
    for (let i = 1; i <= H; i++) sum += Math.abs(imag[i]);
    const norm = sum > 0 ? 1 / sum : 1;
    // 基本波を残したいので、奇数倍音だけを弱める方向でスケール
    for (let i = 3; i <= H; i += 2) imag[i] *= 2.2 * norm;

    return ac.createPeriodicWave(real, imag, { disableNormalization: false });
  }

  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

  // pointer pressure: penなら event.pressure (0..1)
  // touchはiOSで当てにならないのでスライダーにフォールバック
  function getPressure(e) {
    if (e.pointerType === "pen" && typeof e.pressure === "number") {
      return clamp(e.pressure, 0, 1);
    }
    // 一般touch/mouseは疑似圧力
    return Number(simPressure.value);
  }

  function setSound(freq, gain, pressure) {
    if (!ac || !osc || !master) return;

    const now = ac.currentTime;

    // freq smooth
    osc.frequency.setTargetAtTime(freq, now, 0.01);

    // gain smooth（クリップ避けで上限）
    const g = clamp(gain, 0.0001, 1.0);
    master.gain.setTargetAtTime(g, now, 0.01);

    // wave step update（段階的）
    const step = stepFromPressure(pressure);
    const m = step / WAVE_STEPS;
    osc.setPeriodicWave(makeMorphWave(m));

    // HUD
    elFreq.textContent = `${freq.toFixed(1)} Hz`;
    elGain.textContent = g.toFixed(4);
    elPress.textContent = pressure.toFixed(2);
    elStep.textContent = `${step}/${WAVE_STEPS}`;
  }

  function startNote(e) {
    ensureAudio();
    if (!ac) return;

    // iOS: must resume after gesture
    if (ac.state !== "running") ac.resume();

    isDown = true;
    startX = e.clientX;
    startY = e.clientY;
    pointerType = e.pointerType || "unknown";
    elPType.textContent = pointerType;

    // show simulate slider when not pen
    simRow.style.display = (pointerType === "pen") ? "none" : "flex";

    // initial sound
    const p = getPressure(e);
    const f = BASE_FREQ;
    const g = 0.12;
    elState.textContent = "playing";
    setSound(f, g, p);
  }

  function moveNote(e) {
    if (!isDown) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    const f = freqFromDx(dx);
    const g = gainFromDy(dy) * 0.2; // 基準音量を少し抑える
    const p = getPressure(e);

    setSound(f, g, p);
  }

  function endNote() {
    if (!isDown) return;
    isDown = false;
    elState.textContent = "ready";

    if (ac && master) {
      const now = ac.currentTime;
      master.gain.setTargetAtTime(0.0001, now, 0.02);
    }
  }

  // ===== Events =====
  btnStart.addEventListener("click", () => ensureAudio());

  pad.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    pad.setPointerCapture?.(e.pointerId);
    startNote(e);
  });

  pad.addEventListener("pointermove", (e) => {
    e.preventDefault();
    moveNote(e);
  });

  pad.addEventListener("pointerup", (e) => {
    e.preventDefault();
    endNote();
  });

  pad.addEventListener("pointercancel", (e) => {
    e.preventDefault();
    endNote();
  });

  // If simulate pressure changes during touch, reflect next move
  simPressure.addEventListener("input", () => {
    if (!isDown) return;
    // fake event-like update
    const f = Number(elFreq.textContent.split(" ")[0]) || BASE_FREQ;
    const g = Number(elGain.textContent) || 0.1;
    const p = Number(simPressure.value);
    setSound(f, g, p);
  });
})();
</script>
</body>
</html>
